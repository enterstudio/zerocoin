// Code generated by protoc-gen-go. DO NOT EDIT.
// source: zerocoin.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	zerocoin.proto

It has these top-level messages:
	Block
	Blockchain
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type Block struct {
	Index        uint64 `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	Hash         string `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
	PreviousHash string `protobuf:"bytes,3,opt,name=previousHash" json:"previousHash,omitempty"`
	Timestamp    int64  `protobuf:"varint,4,opt,name=timestamp" json:"timestamp,omitempty"`
	Data         string `protobuf:"bytes,5,opt,name=data" json:"data,omitempty"`
}

func (m *Block) Reset()                    { *m = Block{} }
func (m *Block) String() string            { return proto1.CompactTextString(m) }
func (*Block) ProtoMessage()               {}
func (*Block) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Block) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Block) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Block) GetPreviousHash() string {
	if m != nil {
		return m.PreviousHash
	}
	return ""
}

func (m *Block) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Block) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type Blockchain struct {
	Blockchain []*Block `protobuf:"bytes,1,rep,name=blockchain" json:"blockchain,omitempty"`
}

func (m *Blockchain) Reset()                    { *m = Blockchain{} }
func (m *Blockchain) String() string            { return proto1.CompactTextString(m) }
func (*Blockchain) ProtoMessage()               {}
func (*Blockchain) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Blockchain) GetBlockchain() []*Block {
	if m != nil {
		return m.Blockchain
	}
	return nil
}

func init() {
	proto1.RegisterType((*Block)(nil), "proto.Block")
	proto1.RegisterType((*Blockchain)(nil), "proto.Blockchain")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Synchronization service

type SynchronizationClient interface {
	SyncLatest(ctx context.Context, opts ...grpc.CallOption) (Synchronization_SyncLatestClient, error)
	SyncAll(ctx context.Context, opts ...grpc.CallOption) (Synchronization_SyncAllClient, error)
}

type synchronizationClient struct {
	cc *grpc.ClientConn
}

func NewSynchronizationClient(cc *grpc.ClientConn) SynchronizationClient {
	return &synchronizationClient{cc}
}

func (c *synchronizationClient) SyncLatest(ctx context.Context, opts ...grpc.CallOption) (Synchronization_SyncLatestClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Synchronization_serviceDesc.Streams[0], c.cc, "/proto.Synchronization/SyncLatest", opts...)
	if err != nil {
		return nil, err
	}
	x := &synchronizationSyncLatestClient{stream}
	return x, nil
}

type Synchronization_SyncLatestClient interface {
	Send(*Block) error
	Recv() (*Block, error)
	grpc.ClientStream
}

type synchronizationSyncLatestClient struct {
	grpc.ClientStream
}

func (x *synchronizationSyncLatestClient) Send(m *Block) error {
	return x.ClientStream.SendMsg(m)
}

func (x *synchronizationSyncLatestClient) Recv() (*Block, error) {
	m := new(Block)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *synchronizationClient) SyncAll(ctx context.Context, opts ...grpc.CallOption) (Synchronization_SyncAllClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Synchronization_serviceDesc.Streams[1], c.cc, "/proto.Synchronization/SyncAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &synchronizationSyncAllClient{stream}
	return x, nil
}

type Synchronization_SyncAllClient interface {
	Send(*Blockchain) error
	Recv() (*Blockchain, error)
	grpc.ClientStream
}

type synchronizationSyncAllClient struct {
	grpc.ClientStream
}

func (x *synchronizationSyncAllClient) Send(m *Blockchain) error {
	return x.ClientStream.SendMsg(m)
}

func (x *synchronizationSyncAllClient) Recv() (*Blockchain, error) {
	m := new(Blockchain)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Synchronization service

type SynchronizationServer interface {
	SyncLatest(Synchronization_SyncLatestServer) error
	SyncAll(Synchronization_SyncAllServer) error
}

func RegisterSynchronizationServer(s *grpc.Server, srv SynchronizationServer) {
	s.RegisterService(&_Synchronization_serviceDesc, srv)
}

func _Synchronization_SyncLatest_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SynchronizationServer).SyncLatest(&synchronizationSyncLatestServer{stream})
}

type Synchronization_SyncLatestServer interface {
	Send(*Block) error
	Recv() (*Block, error)
	grpc.ServerStream
}

type synchronizationSyncLatestServer struct {
	grpc.ServerStream
}

func (x *synchronizationSyncLatestServer) Send(m *Block) error {
	return x.ServerStream.SendMsg(m)
}

func (x *synchronizationSyncLatestServer) Recv() (*Block, error) {
	m := new(Block)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Synchronization_SyncAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SynchronizationServer).SyncAll(&synchronizationSyncAllServer{stream})
}

type Synchronization_SyncAllServer interface {
	Send(*Blockchain) error
	Recv() (*Blockchain, error)
	grpc.ServerStream
}

type synchronizationSyncAllServer struct {
	grpc.ServerStream
}

func (x *synchronizationSyncAllServer) Send(m *Blockchain) error {
	return x.ServerStream.SendMsg(m)
}

func (x *synchronizationSyncAllServer) Recv() (*Blockchain, error) {
	m := new(Blockchain)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Synchronization_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Synchronization",
	HandlerType: (*SynchronizationServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SyncLatest",
			Handler:       _Synchronization_SyncLatest_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SyncAll",
			Handler:       _Synchronization_SyncAll_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "zerocoin.proto",
}

func init() { proto1.RegisterFile("zerocoin.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 238 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x64, 0x8e, 0xc1, 0x4a, 0xc4, 0x30,
	0x10, 0x86, 0x1d, 0xdb, 0x2a, 0x3b, 0x2e, 0x8a, 0x83, 0x87, 0xb0, 0x78, 0x28, 0x3d, 0xe5, 0x20,
	0x45, 0x56, 0xbc, 0x78, 0xd3, 0x93, 0x07, 0x4f, 0xf5, 0x09, 0xb2, 0xdd, 0x40, 0x83, 0xdd, 0x4c,
	0x69, 0xa2, 0xac, 0xfb, 0x02, 0xbe, 0xb6, 0x24, 0x01, 0x6d, 0xd9, 0x53, 0xe6, 0xff, 0xbe, 0x99,
	0xc9, 0xe0, 0xe5, 0x41, 0x8f, 0xdc, 0xb2, 0xb1, 0xf5, 0x30, 0xb2, 0x67, 0x2a, 0xe2, 0x53, 0xfd,
	0x00, 0x16, 0x2f, 0x3d, 0xb7, 0x1f, 0x74, 0x83, 0x85, 0xb1, 0x5b, 0xbd, 0x17, 0x50, 0x82, 0xcc,
	0x9b, 0x14, 0x88, 0x30, 0xef, 0x94, 0xeb, 0xc4, 0x69, 0x09, 0x72, 0xd1, 0xc4, 0x9a, 0x2a, 0x5c,
	0x0e, 0xa3, 0xfe, 0x32, 0xfc, 0xe9, 0x5e, 0x83, 0xcb, 0xa2, 0x9b, 0x31, 0xba, 0xc5, 0x85, 0x37,
	0x3b, 0xed, 0xbc, 0xda, 0x0d, 0x22, 0x2f, 0x41, 0x66, 0xcd, 0x3f, 0x08, 0x5b, 0xb7, 0xca, 0x2b,
	0x51, 0xa4, 0xad, 0xa1, 0xae, 0x9e, 0x10, 0xe3, 0x21, 0x6d, 0xa7, 0x8c, 0xa5, 0x3b, 0xc4, 0xcd,
	0x5f, 0x12, 0x50, 0x66, 0xf2, 0x62, 0xbd, 0x4c, 0xa7, 0xd7, 0xb1, 0xad, 0x99, 0xf8, 0xf5, 0x1e,
	0xaf, 0xde, 0xbf, 0x6d, 0xdb, 0x8d, 0x6c, 0xcd, 0x41, 0x79, 0xc3, 0x96, 0x6a, 0xc4, 0x80, 0xde,
	0x94, 0xd7, 0xce, 0xd3, 0x6c, 0x74, 0x35, 0x4b, 0xd5, 0x89, 0x84, 0x7b, 0xa0, 0x47, 0x3c, 0x0f,
	0xfd, 0xcf, 0x7d, 0x4f, 0xd7, 0x53, 0x1d, 0x3f, 0x58, 0x1d, 0xa3, 0x34, 0xb6, 0x39, 0x8b, 0xfc,
	0xe1, 0x37, 0x00, 0x00, 0xff, 0xff, 0x73, 0xbf, 0x9d, 0x73, 0x5f, 0x01, 0x00, 0x00,
}
